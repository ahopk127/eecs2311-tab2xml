% Created 2021-02-28 Sun 14:19
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\date{\today}
\title{}
\hypersetup{
 pdfauthor={},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.1 (Org mode 9.4.4)}, 
 pdflang={English}}
\begin{document}

\tableofcontents

\newpage\\
\section{Front-End Tests}
\label{sec:orgb2de03a}
Many of the front-end tests are implemented using a \texttt{ViewBot}, a class that simulates a GUI.\\
\subsection{PresenterTest}
\label{sec:orgf38f026}
These test cases were derived by making one test for each important method of \texttt{Presenter}.\\
\begin{itemize}
\item \texttt{testConvert()}: Tests that the Presenter's convert method correctly interacts with the input (gets input text \& instrument, uses the parser to convert the tab and sets the output correctly).  It does not check that the converted MusicXML is correct - that is the backend tests' job.\\
It is implemented by first loading a sample input from a file and converting it using the parser to get the expected output.  Then, the ViewBot simulates inputting this text and selecting the correct instrument (guitar).  Then, the presenter's convert() method is called.  Finally, the ViewBot's output text is compared with the expected output.\\
\item \texttt{testConvertAndSave()}: Tests that the Presenter's \texttt{convertAndSave()} method works properly.  It is basically a combination of \texttt{testConvert} and \texttt{testSaveToFile}.  In addition, it tests that the boolean argument of \texttt{convertAndSave} works properly.\\
It is implemented by loading sample input and issuing a convertAndSave command, similarly to \texttt{testConvert}.  Then, both the View's output and the test file used as output have their contents checked with the correct text.  Like in \texttt{testConvert}, this output is generated by the backend code.\\
\item \texttt{testLoadFromFile()}: Tests that the "Load from File" command works properly.\\
It is implemented by using sample text in a file.  A presenter uses its \texttt{loadFromFile()} command to load the text into a ViewBot, and the ViewBot's input text is compared with the text that was in the file.\\
\item \texttt{testSaveToFile()}: Tests that the "Save to File" command works properly.\\
Some text is put in the output of a ViewBot.  Then, a Presenter uses its \texttt{saveToFile()} command to save the text to a file.  The file's text is compared with the text that was inputted in the ViewBot.\\
\end{itemize}

This testing is sufficient because every method of the Presenter is covered by a test (except the constructor, which is trivial and has only one line of code).  The Presenter's methods are simple enough that only one test is necessary for each.\\
\subsection{PromptingTextAreaTest}
\label{sec:org6d96e3a}
These test cases were derived by making one test case for each of the important functionalities of the \texttt{PromptingTextArea}: the colour and font of the prompt, the prompt text disappearing when the text box is focused, typing text in the box, and setting the area's font.\\
\begin{itemize}
\item \texttt{testPromptColourFont()}: Tests that the text box's colour and font is set properly.\\
This test works by creating a PromptingTextArea, and setting custom fonts with \texttt{setRegularFont()} and \texttt{setPromptFont()}.  The prompt is disabled, and the active colour and font is checked for correctness.  The prompt is enabled, and the same checks are performed.\\
\item \texttt{testPromptFocusChanges()}: Tests that the text box reacts properly to focus changes.\\
This test is implemented by simulating gaining and losing focus on the text box, and testing that the text box's text updates correctly.\\
\item \texttt{testPromptTyping()}: Tests that the text box reacts properly to typing and when methods are run on it (setText and setPromptText).\\
This test works by undergoing several operations (adding and deleting text, gaining and losing focus) while checking the text in the box is correct after each step.  Typing and deleting text is simulated using the setText method.\\
\item \texttt{testSetFont()}: Tests that fonts are set correctly.\\
This test is implemented by disabling the prompt, and setting the font.  The regular, prompt and active fonts are checked for correctness.  Then, the prompt is enabled and the regular, prompt and active fonts are checked again.  The test is repeated, but the prompt starts enabled and is switched to disabled in the second step.  This is done because the setFont method behaves differently based on whether the prompt is enabled or disabled.\\
\end{itemize}

This testing is sufficient because every method of the PromptingTextArea is tested at least once, and all important or complex methods have tests dedicated to them and their related methods: \texttt{testPromptColourFont} tests setRegularFont() and setPromptFont(); \texttt{testPromptTyping} tests setText() and setPromptText(); \texttt{testSetFont} tests setFont().  All other public methods are simple getters or setters, or methods that trivially call one of the tested methods.  In addition, the gain or loss of focus, an important feature of the \texttt{PromptingTextArea}, has its own dedicated testing method.\\
\subsection{ViewTest}
\label{sec:org4f2ff4b}
These tests were derived by making one test for each major method of the View interface.\\
All tests in this section are run once per View supported by the program, and once for the ViewBot.  This ensures that all of the Views support every possible feature.  Any test in this section that requires use of an unimplemented optional method is skipped.\\
All three of these tests are implemented by setting the paramater to some value, then comparing the value set to the value returned by the appropriate get method.\\
\begin{itemize}
\item \texttt{testInputText()}: Tests that all of the standard views can correctly get and set their input text.\\
\item \texttt{testOutputText()}: Tests that all of the standard views can correctly get and set their output text\\
\item \texttt{testInstrumentSelection()}: Tests that all of the standard views can correctly get and set their instrument selection\\
\end{itemize}

This testing is sufficient because, like in the Presenter, every important method in the View interface is tested by one test, except \texttt{showErrorMessage(String, String)}.  The showErrorMessage method cannot be tested automatically (because I do not want to specify \textbf{how} an error message is shown, only that one is shown), and it is trivial enough that I am not worried about it breaking (As of the time this document was written, all implementations of this method have only one line of code).  The View's methods are also simple enough that only one test per View is needed for each method.\\
\section{Back-End Tests}
\label{sec:org30aa61a}
\subsection{ParserTest}
\label{sec:org408513e}
\begin{itemize}
\item \texttt{testTokenizeGuitar()}: Tests that Guitar tablature is split into proper toknens.\\
\item \texttt{testInvalidTuneException()}: Tests if the Guitar tablature tune is invalid.\\
\item \texttt{testTokenizeDrum()}: [To-Do]\\
\end{itemize}
\subsection{NoteTest}
\label{sec:orgcc14605}
\begin{itemize}
\item \texttt{noteTest()}: Tests that the value and index of each of the twelve note types is correct.\\
\item \texttt{testToNote()}: Tests that the text box reacts properly to focus changes.\\
\item \texttt{testToNoteInvalid()}: Tests that trying to convert an invalid string to a note is invalid.\\
\end{itemize}
\end{document}
